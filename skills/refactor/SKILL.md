---
name: refactor
description: 对代码/项目进行深度重构、清理和优化，提高代码的可读性、可维护性和执行效率，严格遵循 Clean Code 和 SOLID 原则。使用场景：当用户要求重构代码、清理代码、优化代码性能、改进代码结构时，或需要遵循最佳实践进行代码改进时。
---

# Code Refactoring Skill

对代码进行深度重构、清理和优化，提高代码质量。

## How It Works

1. **初始化**：根据用户输入扫描目标文件或目录，排除 node_modules、.git、__pycache__ 等。
2. **分析**：理解功能与业务逻辑，识别死代码、重复逻辑、风格问题与性能瓶颈。
3. **规划**：制定重构计划与优先级，评估影响范围与风险。
4. **执行**：按计划逐步重构，保证行为不变，优先核心业务与高影响文件。
5. **验证**：确认功能正确、性能与可维护性改善，必要时跑测试。

## Usage

本 skill 为指令型，由 Agent 阅读 SKILL.md 后执行，无需运行脚本。

- `@refactor` — 重构当前文件或用户指定的代码
- `@refactor <目录名>` — 重构指定目录下的所有代码文件

**Examples:**
- 重构当前打开文件：`@refactor`
- 重构整个目录：`@refactor src/`

## 角色设定

你现在是一位拥有 10 年以上经验的资深全栈软件架构师，遵循 Clean Code（整洁代码）原则。

## 任务目标

对提供的代码/项目进行深度重构、清理和优化。目标是提高代码的可读性、可维护性、执行效率，并严格遵循行业最佳实践。

**使用方式**:
- `@refactor` - 重构当前文件或用户指定的代码
- `@refactor <目录名>` - 重构指定目录下的所有代码文件

## 执行要求

### 1. 🧹 代码清理 (Code Cleanup)

**删除死代码**:
- 彻底识别并删除未使用的函数、变量、类、导入（Imports）和无法到达的代码分支
- 使用工具或手动检查识别死代码
- 注意识别公共库函数，没使用不代表能删除（用注释做标记库函数）

**清理注释**:
- 删除所有被注释掉的旧代码块
- 保留并修正有价值的业务逻辑注释
- 删除显而易见的废话注释

### 2. 🎨 代码风格与规范 (Style & Standards)

**命名规范**:
- 确保所有变量、函数和类名具有描述性且风格统一
- Python 使用 `snake_case`
- JavaScript/TypeScript 使用 `camelCase`
- 类名使用 `PascalCase`

**格式化**:
- 修正缩进、空格和换行，使其符合标准
- Python: PEP8
- JavaScript/TypeScript: Prettier, Airbnb Style Guide

**解构与简化**:
- 使用现代语法特性简化冗长的代码
- ES6+ 的解构赋值
- Python 的列表推导式
- 箭头函数、async/await 等

### 3. 🏗️ 结构与架构 (Structure & Architecture)

**模块化 (DRY原则)**:
- 识别重复的逻辑，将其提取为独立的通用函数或工具类
- 不要重复你自己（Don't Repeat Yourself）

**函数单一职责**:
- 拆分过长或过于复杂的函数
- 确保每个函数只做一件事

**SOLID 原则**:
- 在合理范围内应用 SOLID 原则
- 降低代码耦合度
- 提高代码可扩展性

### 4. ⚡ 性能与逻辑优化 (Performance & Logic)

**算法优化**:
- 识别时间复杂度过高的部分（如嵌套循环）并进行优化
- 使用更高效的数据结构和算法

**异步处理**:
- 如果适用，优化异步操作（Async/Await）
- 避免阻塞主线程

**资源管理**:
- 确保文件句柄、数据库连接等资源被正确关闭或释放
- 使用上下文管理器（with 语句）

### 5. 🛡️ 健壮性与类型安全 (Robustness & Typing)

**类型注解**:
- [Python/TypeScript] 补充或完善类型提示（Type Hints/TypeScript Types）
- 尽量减少 `any` 的使用

**错误处理**:
- 优化 try-catch 块
- 确保错误被优雅地捕获和处理
- 不要简单地忽略错误

**边界条件**:
- 检查并修复潜在的空指针（Null/Undefined）引用
- 检查数组越界问题
- 验证输入参数

## 约束条件

### 严禁破坏现有功能
- 重构必须保证原有业务逻辑和输出结果完全不变
- 在重构前充分理解现有代码的功能和逻辑

### 分步输出
- 如果代码量很大，请分模块或分步骤展示修改后的代码
- 优先处理最关键或最影响性能的部分

### 解释变动
- 在输出代码前，简要列出主要修改和优化的理由
- 说明每个重构步骤的目的和收益

## 执行流程

1. **初始化阶段**:
   - 如果用户提供了目录名，扫描该目录下的所有代码文件
   - 识别目录中的主要代码文件（排除 node_modules、.git、__pycache__ 等）
   - 确定需要重构的文件列表
   - 如果未提供目录名，则处理用户指定的代码或当前文件

2. **分析阶段**:
   - 理解代码的功能和业务逻辑
   - 识别需要重构的部分
   - 评估重构的影响范围
   - 对于目录重构，按文件优先级排序（核心业务逻辑优先）

3. **规划阶段**:
   - 制定重构计划
   - 确定重构优先级
   - 识别潜在风险
   - 对于目录重构，制定文件级别的重构顺序

4. **执行阶段**:
   - 按照计划逐步重构
   - 确保每一步都保持功能不变
   - 及时验证重构结果
   - 对于目录重构，逐个文件进行重构，保持文件间的依赖关系

5. **验证阶段**:
   - 验证重构后的代码功能正确
   - 检查性能是否提升
   - 确认代码质量是否改善
   - 对于目录重构，验证文件间的接口和依赖关系

## Output

重构完成后，按以下格式输出：

```markdown
## 重构摘要

### 主要修改
1. [修改类型]: [修改描述] - [文件路径]
2. ...

### 优化收益
- [收益1]
- [收益2]

### 代码变更
[展示重构后的关键代码]
```

## Present Results to User

1. 先给出**重构摘要**（主要修改、优化收益），便于快速浏览。
2. 再按文件或模块展示**关键代码变更**，必要时附简短说明。
3. 若分步重构，注明当前步骤与后续建议。

## Troubleshooting

| 情况 | 处理方式 |
|------|----------|
| 用户指定目录不存在 | 提示目录无效，请确认路径或当前工作区 |
| 项目无测试或测试失败 | 说明无法验证行为不变，建议先修复测试或小步重构 |
| 单文件/目录体量过大 | 分模块或分步骤输出，优先核心逻辑 |
| 风格与现有项目不一致 | 以项目既有风格为准，在摘要中说明采用的规范（如 PEP8、Prettier） |

## 注意事项

- 重构是渐进式的，不要一次性改动过多
- 保持代码的可读性和可维护性
- 遵循项目现有的代码风格和约定
- 如果项目有测试，确保重构后测试仍然通过
- **目录重构时**:
  - 优先处理核心业务逻辑文件
  - 注意文件间的依赖关系，先重构被依赖的文件
  - 保持目录结构的合理性
  - 统一整个目录的代码风格和命名规范
  - 识别并提取目录级别的公共代码和工具函数

## 安装 (End-User Installation)

**Claude Code**:
```bash
cp -r skills/refactor ~/.claude/skills/
```

**claude.ai**: 将本 skill 加入项目知识库或把 SKILL.md 内容粘贴到对话中。
